/*
 * 교재 114page~
 *  - 객체 구성
 *     : 속성(변수) / 동작(메소드)
 *     : 여러 개의 독립적인 단위 => 부품(:프로그램) => 조립(:프로그래밍)
 *     - 객체를 만들 떄 사용하는 키워드(설계) => 클래스
 *       : 메모리에 저장 후 사용 => 인스턴스
 *       
 * 교재 118page~121page
 *  - 객체에 대한 설계
 *  - 클래스의 구성요소
 *    class ClassName
 *    {
 *      멤버변수
 *        - 인스턴스 변수: 객체 생성시마다 다른 메모리 저장
 *        - 정적 변수: 메모리 공간 1개만 생성 => 공유
 *        => 구분: static 여부(공통 사용 메소드, 싱글턴: 한 개의 객체 생성)
 *                                         -----데이터베이스 연동
 *                                              Spring은 모든 클래스가 싱글턴
 *        => 적용 (객체지향 속 권장): 데이터 보호(캡슐화)
 *                               데이터를 은닉화 => 메소드를 이용해서 접근
 *        => 역할: 읽기(메모리에서 가져오기): getXxx / 쓰기(메모리 저장): setXxx / 자동 생성: lombok
 *        
 *      생성자: 변수에 대한 초기화 담당, 시작과 동시에 처리 가능
 *          : 생략 가능 => 컴파일러에 의해 자동으로 추가 / 매개변수가 없는 생성자(default 생성자)
 *        - 특징
 *          : 클래스명과 동일하다
 *          : 리턴형이 존재하지 않는다
 *            ** void: 리턴형 => 결과값이 없는 경우
 *          : 여러 개의 생성자를 만들 수 있다
 *            => 같은 이름으로 생성 => 오버로딩 지원
 *            *** 오버로딩: 중복 메소드 생성
 *                : 한 개의 클래스 안에서 만든다
 *                : 메소드명이 동일
 *                : 매개변수가 다르다(개수, 데이터형)
 *                : 리턴형은 관계없다
 *       *** 초기화시 주로 생성자 이용
 *                      ----인스턴스 변수, static 변수 모두 가능
 *       *** static 변수에 대한 초기화는 static{}을 이용한다 => 초기화 블록 => static 변수만 가능
 *       
 *      메소드: 기능 설계 => 설정된 변수를 어떻게 사용할 것인가 / 동작
 *       - 자바 단점: CallBack 불가능
 *                  --------시스템에 의해 자동 호출 => 사용자 정의 메소드는 반드시 호출해야 함(자동 호출 x)
 *       - 구성 요소
 *         리턴형: 사용자 요청을 처리한 결과값
 *                => 한 개만 사용 가능
 *         메소드명: 구분자(메소드명이 메모리 주소)
 *                => 변수 식별자와 동일
 *                => 소문자로 시작
 *         매개변수: 사용한 요청한 값 => 여러 개 사용 가능
 *                => 매개변수 3개 이상이면 배열/클래스
 *                => 개수를 모르는 경우: 가변매개변수(...)
 *                                   String s...
 *         [접근지정어] [제어어] 리턴형 메소드명(매개변수) => 선언부
 *         {
 *           구현부
 *         } 
 *    }
 *    
 *    객체지향 프로그램
 *    - 장점
 *      : 코드 재사용: 상속 / 포함
 *      => 유지보수시 사용 용이 => 대형 프로젝트에서 주로 사용
 *      => 클래스 단위로 모듈화 => 업무 분담 용이
 *    - 단점
 *      : 처리 속도가 상대적으로 느림 => 독립적으로 사용
 *                                ------------ => 상속 / 인터페이스 :연결
 *      : 결합성이 높다 => 클래스 수정 시 다른 클래스에 영향
 *        ------------스프링(로드존슨)
 *      : 설계시 많은 시간 투자
 *    - this / this()
 *      this: 클래스 자신의 메모리 주소를 설정 / 멤버변수와 지역변수 간의 구분자
 *          : JVM => 객체 생성될 때 자동으로 주소값을 저장
 *          : 모든 멤버관련 => 메소드, 변수 앞에 반드시 this.를 써야 했지만 현재 생략 가능 => 컴파일러가 자동 설정
 *          (컴파일러 자동 처리: import java.lang.*;
 *                           => 모든 클래스는 Object 상속
 *                              class A extends Object
 *                                      --------------
 *                           => 메소드 안에서 void => return 추가
 *                           => 생성자를 사용하지 않으면 디폴트 생성자 추가
 *                           => this.을 생략시 자동 추가
 *                           =? 생략 가능)
 *     this(): 자신 클래스의 생성자를 호출 시에 주로 사용
 *           : 사용 빈도 거의 없음
 *           : 사용 위치 => 생성자 안에서 다른 생성자를 호출할 때
 *           : 생성자 첫 줄에 위치 => 문법상의 오류발생
 *   
 *  122page~: 객체 생성과 사용
 *    객체의 생명 주기
 *      설계(class 작성) ==> 메모리 저장 ==> 활용 ==> 메모리 회수
 *      class ClassName => new 생성자() => .메소드() => null => System.gc()
 *      {                                .변수명
 *        변수/메소드/생성자
 *      }
 *      *** 변수만 가지고 있는 경우
 *          : 데이터형 클래스(사용자 정의 데이터형)
 *            => 관련된 데이터를 모아 한 번에 관리
 *      *** 메소드만 가지고 있는 경우
 *      *** 변수+메소드
 *      => 관련된 내용을 모아서 관리
 *          
 */
class A
{
	void disp(int a)
	{
		System.out.println("disp() Call:"+a);
	}
}
public class 객체지향_1 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		A aa=new A();
		aa.disp(100);
		A bb=new A();
		bb.disp(1000);
		/*
		 *  123page~
		 *  A aa; 선언 후
		 *  aa=new A(); 저장
		 *  
		 *  A aa=new A(); 선언과 동시에 저장
		 */
		
	}

}
