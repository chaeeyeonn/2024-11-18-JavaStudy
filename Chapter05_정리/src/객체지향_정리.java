/*
 *   1. 클래스 구조
 *      클래스: 객체를 생성하기 위한 설계
 *            ---속성(변수) / 동작(메소드)
 *      class ClassName
 *      {
 *         변수
 *           - 멤버변수(인스턴스): 객체 생성시마다 메모리 따로 저장
 *             [접근지정어] 데이터형 변수명;
 *             ---------데이터 보호(정보 은닉) => private
 *           - 정적변수(static, 필드): 메모리 공간 1개 생성(공유)
 *             [접근지정어]static 데이터형 변수명;
 *         생성자: 멤버변수 설정 => 초기화: 1) 명시적 초기화: 임의로 설정 => class 영역은 선언만 하는 영역
 *               ------               2) 구현 후 초기화: 파일 읽기 / 데이터베이스 (연산자 / 제어문 => 구현 => 클래스 영역에서 설정 불가능)
 *               기본값은 설정되어 있음         - 생성자: 인스턴스 변수 / static 변수 설정 가능
 *                                         - 인스턴스 블록: 인스턴스 변수 / static 변수 설정 가능
 *                                         - static 블록: static 변수 설정 가능
 *                                                       객체 생성 후 사용
 *                                         => 특별한 경우 아니면 생성자 주로 이용
 *                                            --------static 변수 => 목록(배열/클래스)
 *                          => 특징: 클래스명과 동일 / 오버로딩 가능 / 리턴형 없음 / 다른 클래스 사용 가능 => public
 *                                               : 메소드명 동일  ------class A
 *                                               : 리턴형 관계없음     {
 *                                    : 매개변수 다름(데이터형, 개수)        void A(){} => 일반 메소드
 *                                               : 접근지정어 관계없음     A(){} => 생성자
 *                                                                  }
 *                          => *** 생성자가 없는 경우 컴파일러에 의해 default 생성자 자동 추가
 *                          => *** default 생성자는 매개변수가 없음
 *         메소드: 동작, 행위 => 기능처리
 *               => 데이터 결과값 전송
 *               => 다른 클래스와 연결
 *               [접근지정어] 리턴형 메소드명(매개변수) => 선언부
 *               {
 *                  => 구현부
 *                  return 값
 *                  ***void일 때는 return 생략 가능
 *                     => 컴파일러에 의해 자동 추가됨
 *               }
 *              : 사용자 정의시 반드시 호출
 *              : 인스턴스 => 객체명.메소드(값...)
 *                => 다른 클래스에 사용시에는 객체를 생성한 후 접근
 *                   Scanner scan=new Scanner();
 *                   a= scan.next;
 *                stsic => 클래스명.메소드(겂...) => 자도 메모리 할당
 *                   Math.random();
 *      }              
 *      
 *   2. 멤버 변수
 *        - 멤버 변수 : Heap => 클래스 종료시 
 *                  : 클래스에 있는 모든 곳에서 사용 가능
 *                  : 생성: new를 이용해서 객체 생성
 *        - 정적 변수: MethodArea
 *   3. 생성자
 *   4. 메소드
 *   5. 접근지정어
 *      : 클래스, 메소드, 멤버변수만 사용 가능 / 지역변수는 x
 *        **private: 자신의 클래스에서만 사용 가능
 *                   은닉화 => 모든 멤버변수는 private
 *        **public: 모든 클래스에서 사용 가능
 *                  => 클래스, 메소드, 생성자
 *        protected: 같은 패키지 안에서만 사용 가능
 *                   다른 패키지 => 상속받은 클래스
 *                   => 사용 빈도 거의 없음
 *        default: 같은 패키지에서만 사용 가능
 *                 윈도우 => 버튼, 편집기, ...
 *      ** 접근 범위
 *         private < default < protected < public
 *         => 오버라이딩 
 *         => 접근지정어의 확장 가능 / 축소 불가
 *      ===> 객체 지향의 3대 특성
 *           1) 캡슐화: 개인 정보 보호
 *              => 변수: private
 *              => 변수 기능 추가: getter / setter
 *           2) 상속 / 포함: 재사용 기법 / 중복코드 제거
 *              => 소스 볼 수 없음: 가독성 낮음
 *              => 속도가 느려짐
 *              => 변경 어려움 => 다른 클래스에 많은 영향
 *              => 형변환
 *              => 클래스는 크기를 잴 수 없음
 *           3) 기능 변경 / 기능 추가
 *              오버라이딩 / 오버로딩 => 다형성
 *       
 *   6. 캡슐화: 데이터 보호 => 데이더를 감춘다 => private
 *            => 필요시에 사용 => 메소드 이용
 *            => 저장: setter / 읽기: getter
 *   7. 패키지: 폴더 개념 => 관련된 클래스 모아 검색이 쉽게 만듦
 *            다른 패키지에서 사용: import
 *                             -------
 *                             1. 라이브러리
 *                             2. 사용자 정의 클래스
 *                             3. 같은 패키지에서는 import를 사용 안 함
 *                    => 패키지명에 키워드는 사용 불가능
 *                    => 소문자 사용
 *                    => 공백 x
 *                    => 특수문자 x
 *                    => 클래스 분리
 *                    => 네트워크
 *                       client / server / commons
 *                       웹
 *                       admin / user
 *                    => com(org).회사명.종류
 *                                     ----vo, dao, io
 *   8. static 사용시 주의점
 *      static 메소드 안에서는
 *        1) static 변수 사용 가능
 *        2) static 메소드 호출 가능 => 인스턴스 사용시 반드시 객체 생성
 *        3) this, this() 사용 불가 => 인스턴스 메소드, 생성자에서 가능
 *           ----자신의 객체 주소 가지고 있음 => 인스턴스 변수 / 지역 변수 구분시 주로 사용
 *               윈도우: 현재 실행중인 윈도우(this) 전송 
 *           this(): 생성자 안에서만 새용 가능
 *                   생성자 안에서 다른 생성자 호출할 때 사용
 *                   => 생성자 첫 번째에 위치
 *     static{} 사용 방법
 *        static 변수로 배열 / 클래스 => 초기화시 주로 사용
 *                          -----라이브러리(MyBatis)
 *                    ----목록
 *        => 블록 안에서는 static만 초기화 가능
 *        
 *   9. 객체 생성 => 클래스 객체명=new 생성자()
 *                 ---------------------
 *                 클래스 객체명;
 *                 객체명=new 생성자()
 *      객체 => 메모리 주소 저장
 *      참조
 *      class A
 *      A a=new A();
 *      A b=a;      ===> a와 b는 같은 메모리 제어 ===> Call By Reference
 *      ==> 메소드의 매개변수 이용
 *   ---------------
 *   
 *   6장: 상속 / 포함 / 클래스 종류(추상클래스 / 인터페이스)
 *        |오버라이딩
 *   8장: 예외처리
 *   9장: java.lang / java.util(Collection)
 *   10장: **java.io / java.net / java.text
 *   11~12장: **java.sql(오라클 연동)
 * 
 */
public class 객체지향_정리 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

	}

}
