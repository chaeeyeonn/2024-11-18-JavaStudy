/* 
 * // 가급적 => 같은 기능의 변수가 3개 이상이면 => 배열 사용
 * //          다른 기능의 변수가 3개 이상이면 => 클래스 사용
 * int kor1,kor2,kor3; => int[3] kor
 * int eng1,eng2,eng3; => int[3] eng
 * 
 *   변수 여러 개 => 일차원 배열
 *                 =======> 이차원 배열 =======> 삼차원 배열
 *   
 *   (교재85page)
 *   1. 배열 생성
 *      배열: 연속적인 메모리 구조를 가지고 있다
 *           -----------index 번호
 *      
 *      인덱스: => 항상 0번부터 순차적으로
 *      
 *      배열 선언
 *      가장 많이 사용되는 배열 생성
 *      => 데이터형[] 배열명= new 데이터형[배열 개수 지정]
 *                                  -------------데이터 접근: 배열명.length-1
 *                                               배열의 인덱스를 벗어나면 => ArrayIndexOutOfBoundsException 뜸
 *        데이터형[] 배열명; => 권장
 *        데이터형 배열명[]; => C/C++ 호환
 *        
 *        데이터형[] 배열명;
 *        --------
 *        배열에 저장되는 데이터 종류
 *        [] => 배열 기호
 *        [0] => 배열 인덱스 => 저장 위치
 *               배열 첨자
 *        배열명: 실제 저장되어 있는 주소를 참조 => 참조 변수
 *        
 *      배열 초기화  => 데이터 메모리에 저장: 저장하는 값 -> 초기화
 *      
 *      1) 정수형
 *         int[] arr={1,2,3,4,5};
 *                   ===========5개의 메모리 공간을 연속적으로 배치
 *         int[] arr=new int[5]; ==> 배열에 쓸 메모리 공간 5개를 달라
 *                  ------------자동 초기화
 *                  int ==> 0
 *                  long ==> 0L
 *                  char ==> '\u0000' => '\0'
 *                  float ==> 0.0F
 *                  double ==> 0.0
 *                  boolean ==> false
 *                  
 *                  [I@5ccd43c2 => 배열 주소
 *                  
 *        int[] arr
 *        ---------
 *        주소를 참조해 데이터 관리 => 참조 변수
 *        Stack공간에 저장          실제 데이터 저장 공간(Heap)
 *           arr                 [I@5ccd43c2
 *        ---------                  ---------------------------
 *        [I@5ccd43c2    =====>       0  |  0  |  0  |  0  |  0     
 *        ---------                  ---------------------------
 *                                   arr[0] [1]  [2]   [3]   [4]
 *                                   ==> index 번호
 *                                   arr+0*4(4byte) arr+1*4 arr+2*4 ...
 *                                   long => *8
 *                                   double => *8
 *                                   char => *2
 *        int a=10; ==> arr[0] => 둘다 변수임
 *        arr[0]=10;
 *        arr[1]=100;
 *        // 인덱스 하나에 하나 넣은 것
 *        
 *        => 연속적인 메모리 구조
 *           -----------
 *           인덱스 번호를 이용해서 접근
 *         1. 배치 => 인덱스 번호 부여
 *         2. 인덱스 변호를 이용해 데이터 값 수정 / 읽기 / 첨부
 *         3. 0부터 순차적이기 때문에 => 반복문으로 처리 가능
 *         
 *        => 종류
 *          1. 정수: int[] 배열명
 *          2. char: char[] 배열명
 *          3. 실수: double[] 배열명
 *          4. 논리: boolean[] 배열명
 *          5. 문자열: String[] 배열명
 *          
 *        => 생성(86page)
 *           new 데이터형[배열 크기] => 고정적 메모리(크기 고정)     
 *           
 *        => 배열의 개수 확인 => 배열명.length => ()안 씀

 * 
 */
public class 배열_생성_1 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		// 배열 선언
		int[] arr=new int[5];
		//                - 배열 개수(int => 5개 모아서 관리)
		// 배열값 초기화
		for(int i=0;i<arr.length;i++)
		{
			arr[1]=(int)(Math.random()*100)+1;
			//i=0~4
		}
		//실제값을 확인
		for(int i=0;i<arr.length;i++)
		{
			System.out.println("arr["+i+"]="+arr[i]);
		}
		System.out.println("======배열값 출력======");
		/* 92page
		 * => 출력용 ==> for~each: 향상된 for문
		 *  for(데이터형 변수:배열명(컬렉션))
		 *  {   ------     ----배열에 선언된 데이터형과 동일 / 배열, 컬렉션만 사용 가능
		 *        | 인덱스를 이용하지 않음 => 실제저장된 값을 순차적으로 가져온다
		 *        | 마지막 값을 가져오면 자동으로 종료
		 *        | 웹의 Front 핵심
		 *        | 단점: 배열값 변경, 추가 불가 ==> 인덱스 번호 이용해야함
		 *  }
		 *  
		 *  int[] arr= {1,2,3,4,5}
		 *  arr(Stack)       Heap
		 *                      arr[1] arr[2] ...
		 *  ---------           -----------
		 *  0*100(번지라고 한다면)  1  2  3  4  5
		 *  ---------           -----------
		 *                      | 0*100의 첫 번째 값
		 *                      
		 *  int[] arr= {1,2,3,4,5}
		 *  |동일하거나 더 큰 데이터형 사용
		 *  for(int(long,double) 받는 변수(a라 한다면):arr)
		 *  => a=1
		 *     a=2
		 *     a=3
		 *     a=4
		 *     a=5
		 *     종료 => 인덱스를 이용x, 실제 저장된 값
		 */
		    

	}

}
